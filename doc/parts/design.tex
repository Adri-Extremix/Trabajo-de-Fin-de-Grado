\chapter{Diseño}\label{chap:diseno}

En este capítulo se detalla el diseño que tendrá la solución propuesta. Para ello se discutirán sobre las posibles alternativas y cuál de ellas ha sido elegida (\sectionref{estudio-solucion-final}) y posteriormente, se describirá la arquitectura del sistema (\sectionref{arquitectura-sistema}) en base a la solución final elegida.

\section{Estudio de la solución final}\label{sec:estudio-solucion-final}

Para la realización del estudio de la solución final se han tenido en cuenta los requisitos especificados en \sectionref{requisitos} y las herramientas existentes descritas en \chapterref{estado-del-arte}. 

\subsection{Monolítico vs Distribuido} \label{sec:monolitico-vs-distribuido}

Durante la especificación de los requisitos se han descrito varios requisitos que influyen en la elección del sistema operativo y de la arquitectura del sistema. En concreto los requisitos \sreqref{NF-abstraccion-so} y \sreqref{NF-abstraccion-arch} especifican que la herramienta debe de tener el mismo funcionamiento aunque la arquitectura del sistema o el sistema operativo sean diferentes. Estos requisitos nos obligan a tomar una decisión respecto a la arquitectura del sistema. 

\subsubsection{Monolítico} \label{sec:monolitico}

Una aplicación monolítica es aquella que se ejecuta en un único proceso y en un único sistema operativo. Este tipo de aplicaciones son más sencillas de desarrollar y de mantener, ya que no requieren de una comunicación entre procesos. Sin embargo, una aplicación monolítica no es capaz de ejecutarse en diferentes sistemas operativos, ya que el código fuente debe de ser compilado para cada sistema operativo. Dado que el requisito \sreqref{NF-multiplataforma} indica que el sistema debe de poder ejecutar en cualquier sistema operativo, el monolítico no es una opción viable.

\subsubsection{Distribuido} \label{sec:distribuido}

Una aplicación distribuida es aquella que se ejecuta en múltiples procesos. Este tipo de aplicaciones tienen una mayor complejidad de desarrollar, debido a la comunicación entre procesos. Sin embargo, una aplicación distribuida que sirva un servicio web podría funcionar en cualquier sistema operativo, dado que solo ejecutaría el código del cliente, y además contemplaría el requisito \sreqref{NF-ejecucion-POSIX}, que indica que el sistema debe de ejecutarse en un sistema operativo UNIX para soportar la ejecución de hilos POSIX. Esta arquitectura permitiría tener una única aplicación web que se pueda ejecutar el lado cliente en cualquier sistema operativo y arquitectura, mientras se utiliza un servidor que ejecuta en un sistema operativo UNIX que permita la ejecución de hilos POSIX.

Durante la sección \sectionref{arquitectura-sistema} se detallarán cómo se ha implementado este diseño distribuido. 

\subsection{Depuración} \label{sec:depuracion}

Para implementar la depuración concurrente existen varias alternativas. 

\subsubsection{Almacenamiento de estados} \label{sec:almacenamiento-estados}

Para implementar las operaciones básicas de un depurador es necesario moverse por la ejecución del código. Es por esta razón que se evaluó la posibilidad de inyectar código en el programa cuyo propósito sea almacenar el estado de la ejecución en un momento determinado. Con estos estados almacenados el usuario podría moverse entre cada uno de ellos, facilitando el rebobinado de la ejecución.

Para almacenar estos estados sería necesario introducir código en el programa tras cada sentencia que modifique el estado de la ejecución, es decir, creación de variables, modificación de variables o llamadas al sistema que generasen nuevos hilos. Lo que supone crear un \textit{\gls{parser}} para encontrar estas sentencias y añadir a continuación una función que almacene la variable y su valor en la función e hilo correspondiente. 

Sin embargo, el desarrollo del \textit{\gls{parser}} supone una gran complejidad debido a las numerosas sentencias que tener en cuenta, por lo que se decidió explorar nuevas alternativas.

\subsubsection{Uso de depuradores externos} \label{sec:depuradores-externos}

Dado que implementar un depurador desde 0 supone una gran complejidad, se ha evaluado la opción de utilizar un depurador externo. Durante el \chapterref{estado-del-arte} se analizaron los depuradores existentes, dentro de estos depuradores tan solo GDB (\subsectionref{gdb}), LLDB (\subsectionref{lldb}) y RR (\subsectionref{rr}) permitían construir una aplicación sobre ellos. Aunque LLDB tenga una API en Python que permita la interactividad con la sesión de depuración, carece de la capacidad de rebobinar durante la depuración, tal y como indica el requisito \sreqref {FN-rebobinar}. Por lo tanto, RR es una opción más viable, que aunque no ofrezca una API en Python que permita la interactividad, sí que ofrece una interfaz máquina que ofrece una salida formateada.

No obstante, RR registra la ejecución del programa para reproducirla posteriormente, garantizando así una ejecución determinista. Esto limitaría la capacidad del usuario para modificar el flujo de ejecución a su conveniencia. Por ello, se ofrecerá la opción de elegir entre grabar la ejecución, permitiendo el rebobinado, o no grabarla (utilizando solo GDB), permitiendo una ejecución libre de los hilos.

\subsection{Sandbox} \label{sec:sandbox}

Tal y como se indica en \sreqref{NF-sandbox}, el sistema debe de ejecutar el código en un entorno aislado para evitar problemas de seguridad o disponibilidad. Para ello, se optó por utilizar contenedores Docker en los que se ejecutarán los programas. De esta manera cualquier código malicioso no podrá acceder a los archivos del sistema ni atacar a la disponibilidad del servidor. Además se limitarán los recursos del contenedor para controlar el uso de los mismos.

\subsection{Comunicación entre procesos} \label{sec:comunicacion-procesos}




\subsection{Lenguajes de Programación} \label{sec:programacion}

Dada la arquitectura distribuida del sistema, se necesita usar un lenguaje de programación para el lado cliente y otro para el lado servidor.

\subsubsection{Tecnologías del lado cliente} \label{sec:tecnologias-cliente}

Para la construcción de la aplicación web se ha basará en HTML5 para dar estructura al código, CSS3 para dar estilos, sin embargo para implementar las distintas funcionalidades existen diferentes tecnologías.

\begin{itemize}
    \item \textbf{JavaScript Vanilla}: Lenguaje nativo del navegador, con el que ya se tiene experiencia. Ofrece control total sobre el código, pero requiere más esfuerzo para funcionalidades complejas.
    \item \textbf{React}: Biblioteca enfocada en la creación y gestión de componentes, aunque requiere un tiempo de aprendizaje adicional.
    \item \textbf{Angular}: Framework completo con una curva de aprendizaje pronunciada, no adecuado para el alcance de este proyecto.
    \item \textbf{jQuery}: Biblioteca con la que se tiene experiencia, simplifica la manipulación del DOM y las peticiones AJAX, lo que facilitaría el desarrollo.
\end{itemize}

Dada la pequeña envergadura que tendrá la aplicación web, se optará por jQuery, por la experiencia previa que se tiene y la simplificación de manipulaciones del DOM y peticiones AJAX.

\subsubsection{Tecnologías del lado servidor} \label{sec:tecnologias-servidor}

En cuanto al lenguaje de programación del lado servidor es necesario elegir un lenguaje que permita la creación de un servidor web, que trabaje con ficheros para la creación de ficheros con el código del usuario, que permita la concurrencia para poder soportar varios usuarios al mismo tiempo, y que permita crear un proceso en el que ejecutar RR.
Dentro de las opciones destacan Python, Go, Rust y NodeJS, por lo que vamos a analizar cada una de ellas.

\begin{itemize}
    \item \textbf{Python}: Un lenguaje de programación interpretado, muy versátil, aunque con un rendimiento moderado. Gracias al framework Flask, para crear un servidor web, y al módulo threading, para la concurrencia, es una opción viable. 
    \item \textbf{Go}: Un lenguaje de programación compilado, con un buen rendimiento y orientado en la concurrencia y el procesamiento en la red. Gracias a al soporte nativo para concurrencia a través de las goroutines, y al framework net/http, para crear un servidor web, es una opción viable.
    \item \textbf{Rust}: Un lenguaje de programación compilado, con un gran rendimiento, aunque con un curva de aprendizaje pronunciada. Si bien es una opción viable, no es la más recomendable. 
    \item \textbf{NodeJS}: Un lenguaje de programación interpretado, cuya concurrencia se basa en un solo hilo utilizando un bucle de eventos y un modelo asíncrono; lo que no es un paralelismo real. Es por esta razón que no es una opción demasiado recomendable. 
\end{itemize}

Tanto Go como Python son lenguajes adecuados para el proyecto. Aunque Go ofrece un rendimiento superior, la disponibilidad de la biblioteca Python \textit{pygdbmi}, que facilita la gestión de una sesión RR/GDB y la obtención de la salida MI en formato JSON, convierte a Python en la opción más conveniente.

\section{Arquitectura del sistema}\label{sec:arquitectura-sistema}

Tal y como se ha comentado en \sectionref{estudio-solucion-final}, el sistema consta de tres partes: el cliente, el servidor y el contenedor docker, y cada uno de ellos consta de varios componentes. 

\begin{itemize}
    \item \textbf{Cliente}: Permite facilitar la interacción del usuario con el depurador, además de visualizar las salidas y cambios ocurridos durante la ejecución. En este componente se podrá escribir código, y comunicará las acciones al servidor para ejecutar las correspondientes funcionalidades. 
    Dentro de la aplicación web, existen dos componentes principales:

    \begin{itemize}
        \item \textbf{Intefaz Gráfica}: Su responsabilidad es actulizar la información que se muestra por pantalla-
        \item \textbf{Comunicación con el Servidor (Web Socket)}: Se encargará enviar y recibir mensajes del servidor.
        \item \textbf{Editor de Código} Su responsabilidad es permitir al usuario escribir el código que se va a depurar.
        \item \textbf{Depurador}: Gestionará la interacción del usuario con el depurador, permitiendo la ejecución de las funcionalidades de depuración.
    \end{itemize}

    \item \textbf{Servidor}: Se encargará de gestionar las peticiones de los clientes y ejecutar las funcionalidades solicitadas en los contenedores
    Este componente consta de tres componentes principales:
    \begin{itemize}
        \item \textbf{Gestión de Clientes}: Aceptará las conexiones de los clientes y creará hilos para cada una de las sesiones
        \item \textbf{Comunicación con el Cliente (Web Socket)}: Se encargará de recibir y enviar mensajes a los clientes. 
        \item \textbf{Gestión de la Sesión de Depuración}: Se encargará de gestionar un contenedor docker para la sesión. Comunicará al contenedor las acciones que se realizan desde el cliente, y recibirá las respuestas del contenedor. 
    \end{itemize}

    \item \textbf{Contenedor Docker}: Se encargará de ejecutar el código del usuario y gestionar la sesión de depuración. Este componente consta de dos componentes principales:
    \begin{itemize}
        \item \textbf{Docker API}: El contenedor servirá una API REST para la comunicación con el exterior. Esta API permitirá realizar acciones asociadas a la depuración.
        \item \textbf{Funcionalidades de Depuración}: Este componente contendrá la implementación de las funcionalidades de depuración, las cuales serán llamadas a través de la API.
    \end{itemize}
\end{itemize}

En la figura \ref{fig:componentes_TFG} se muestra el diagrama de componentes UML \cite{Cook2017} donde se pueden observar los distintos componentes y sus diferentes interfaces.

\drawiosvgfigure[0.7]{componentes_TFG}{Diagrama de componentes del sistema}

Para la especificación de los distintos componentes se ha usado la siguiente plantilla: 

\printcomptemplate

\begin{component}{Interfaz Gráfica}
{Mostrar la información actualizada al usuario por pantalla}
{} % dependencias
{Estado actual del sistema} % in-data
{NA} % out-data
{FN-GUI} % relations
La Interfaz Gráfica debe de gestionar la interacción del usuario con la aplicación y mostrar la información de manera estructurada y clara. %description 
\end{component}




\FloatBarrier
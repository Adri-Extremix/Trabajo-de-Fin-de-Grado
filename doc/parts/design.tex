\chapter{Diseño}\label{chap:diseno}

En este capítulo se detalla el diseño que tendrá la solución propuesta. Para ello se discutirán sobre las posibles alternativas y cuál de ellas ha sido elegida (\sectionref{estudio-solucion-final}) y posteriormente, se describirá la arquitectura del sistema (\sectionref{arquitectura-sistema}) en base a la solución final elegida.

\section{Estudio de la solución final}\label{sec:estudio-solucion-final}

Para la realización del estudio de la solución final se han tenido en cuenta los requisitos especificados en \sectionref{requisitos} y las herramientas existentes descritas en \chapterref{estado-del-arte}. 

\subsection{Monolítico vs Distribuido} \label{subsec:monolitico-vs-distribuido}

Durante la especificación de los requisitos se han descrito varios requisitos que influyen en la elección del sistema operativo y de la arquitectura del sistema. En concreto los requisitos \sreqref{NF-abstraccion-so} y \sreqref{NF-abstraccion-arch} especifican que la herramienta debe de tener el mismo funcionamiento aunque la arquitectura del sistema o el sistema operativo sean diferentes. Estos requisitos nos obligan a tomar una decisión respecto a la arquitectura del sistema. 

\subsubsection{Monolítico} \label{subsubsec:monolitico}

Una aplicación monolítica es aquella que se ejecuta en un único proceso y en un único sistema operativo. Este tipo de aplicaciones son más sencillas de desarrollar y de mantener, ya que no requieren de una comunicación entre procesos. Sin embargo, una aplicación monolítica no es capaz de ejecutarse en diferentes sistemas operativos, ya que el código fuente debe de ser compilado para cada sistema operativo. Dado que el requisito \sreqref{NF-multiplataforma} indica que el sistema debe de poder ejecutar en cualquier sistema operativo, el monolítico no es una opción viable.

\subsubsection{Distribuido} \label{subsubsec:distribuido}

Una aplicación distribuida es aquella que se ejecuta en múltiples procesos. Este tipo de aplicaciones tienen una mayor complejidad de desarrollar, debido a la comunicación entre procesos. Sin embargo, una aplicación distribuida que sirva un servicio web podría funcionar en cualquier sistema operativo, dado que solo ejecutaría el código del cliente, y además contemplaría el requisito \sreqref{NF-ejecucion-POSIX}, que indica que el sistema debe de ejecutarse en un sistema operativo UNIX para soportar la ejecución de hilos POSIX. Esta arquitectura permitiría tener una única aplicación web que se pueda ejecutar el lado cliente en cualquier sistema operativo y arquitectura, mientras se utiliza un servidor que ejecuta en un sistema operativo UNIX que permita la ejecución de hilos POSIX.

Durante la sección \sectionref{arquitectura-sistema} se detallarán cómo se ha implementado este diseño distribuido. 

\subsection{Depuración} \label{subsec:depuracion}

Para implementar la depuración concurrente existen varias alternativas. 

\subsubsection{Almacenamiento de estados} \label{subsec:almacenamiento-estados}

Para implementar las operaciones básicas de un depurador es necesario moverse por la ejecución del código. Es por esta razón que se evaluó la posibilidad de inyectar código en el programa cuyo propósito sea almacenar el estado de la ejecución en un momento determinado. Con estos estados almacenados el usuario podría moverse entre cada uno de ellos, facilitando el rebobinado de la ejecución.

Para almacenar estos estados sería necesario introducir código en el programa tras cada sentencia que modifique el estado de la ejecución, es decir, creación de variables, modificación de variables o llamadas al sistema que generasen nuevos hilos. Lo que supone crear un \textit{\gls{parser}} para encontrar estas sentencias y añadir a continuación una función que almacene la variable y su valor en la función e hilo correspondiente. 

Sin embargo, el desarrollo del \textit{\gls{parser}} supone una gran complejidad debido a las numerosas sentencias que tener en cuenta, por lo que se decidió explorar nuevas alternativas.

\subsubsection{Uso de depuradores externos} \label{subsec:depuradores-externos}

Dado que implementar un depurador desde 0 supone una gran complejidad, se ha evaluado la opción de utilizar un depurador externo. Durante el \chapterref{estado-del-arte} se analizaron los depuradores existentes, dentro de estos depuradores tan solo GDB (\subsectionref{gdb}), LLDB (\subsectionref{lldb}) y RR (\subsectionref{rr}) permitían construir una aplicación sobre ellos. Aunque LLDB tenga una API en Python que permita la interactividad con la sesión de depuración, carece de la capacidad de rebobinar durante la depuración, tal y como indica el requisito \sreqref {FN-rebobinar}. Por lo tanto, RR es una opción más viable, que aunque no ofrezca una API en Python que permita la interactividad, sí que ofrece una interfaz máquina que ofrece una salida formateada.

No obstante, RR registra la ejecución del programa para reproducirla posteriormente, garantizando así una ejecución determinista. Esto limitaría la capacidad del usuario para modificar el flujo de ejecución a su conveniencia. Por ello, se ofrecerá la opción de elegir entre grabar la ejecución, permitiendo el rebobinado, o no grabarla (utilizando solo GDB), permitiendo una ejecución libre de los hilos.

\subsection{Sandbox} \label{subsec:sandbox}

Tal y como se indica en \sreqref{NF-sandbox}, el sistema debe de ejecutar el código en un entorno aislado para evitar problemas de seguridad o disponibilidad. Para ello, se optó por utilizar contenedores Docker en los que se ejecutarán los programas. De esta manera cualquier código malicioso no podrá acceder a los archivos del sistema ni atacar a la disponibilidad del servidor. Además se limitarán los recursos del contenedor para controlar el uso de los mismos.

Para ello se tendrá una imagen base de Docker que contenga el código del depurador. Cada contenedor se creará a partir de esta imagen base, y se levantará por cada sesión de cada usuario. De esta manera, cada usuario tendrá su propio contenedor, y no podrá acceder a los contenedores de otros usuarios, además de si se ejecuta codigo malicioso, este no podrá afectar al servidor. 


\subsection{Comunicación entre procesos} \label{subsec:comunicacion-procesos}

Dada la existencia de un cliente, un servidor y un contenedor, es necesario establecer una comunicación entre ellos. Esta comunicación se puede realizar de diferentes maneras, pero se han considerado las dos siguientes opciones: 

\begin{itemize}
    \item \textbf{REST}: Permite la comunicación entre procesos a través de peticiones HTTP. Esta comunicación es unidireccional, sin control de estados y se establece una conexión por cada petición. Es ideal para controlar una gran cantidad de comunicaciones y para servir unos recursos.
    \item \textbf{Web Sockets}: Permiten la comunicación entre el cliente y el servidor a través de una conexión TCP/IP. Esta comunicación es bidireccional, y permite el envío de mensajes en tiempo real. Es ideal para aplicaciones que requieren una comunicación constante entre el cliente y el servidor.
\end{itemize}

Dadas las características de la aplicación, se optará por usar REST API únicamente para servir los ficheros estáticos y Web Sockets para la comunicación entre el cliente y el servidor, ya que permite gestionar sesiones con los clientes, lo que permitiría crear un contenedor por cada cliente. Por otro lado, la comunicación entre el servidor y el contendor se realizará a través de WebSocktets, ya que permite la comunicación en tiempo real y es más eficiente que REST. 
Es por esto que el backend aceptará la comunicación con los clientes y redirigirá los mensajes recibidos al contenedor asociado a esa sesión. 

\subsection{Lenguajes de Programación} \label{sec:programacion}

Dada la arquitectura distribuida del sistema, se necesita usar un lenguaje de programación para el lado cliente y otro para el lado servidor.

\subsubsection{Tecnologías del lado cliente} \label{subsubsec:tecnologias-cliente}

Para la construcción de la aplicación web se ha basará en HTML5 para dar estructura al código, CSS3 para dar estilos, sin embargo para implementar las distintas funcionalidades existen diferentes tecnologías.

\begin{itemize}
    \item \textbf{JavaScript Vanilla}: Lenguaje nativo del navegador, con el que ya se tiene experiencia. Ofrece control total sobre el código, pero requiere más esfuerzo para funcionalidades complejas.
    \item \textbf{React}: Biblioteca enfocada en la creación y gestión de componentes, aunque requiere un tiempo de aprendizaje adicional.
    \item \textbf{Angular}: Framework completo con una curva de aprendizaje pronunciada, no adecuado para el alcance de este proyecto.
    \item \textbf{jQuery}: Biblioteca con la que se tiene experiencia, simplifica la manipulación del DOM y las peticiones AJAX, lo que facilitaría el desarrollo.
\end{itemize}

Dada la pequeña envergadura que tendrá la aplicación web, se optará por jQuery, por la experiencia previa que se tiene y la simplificación de manipulaciones del DOM y peticiones AJAX.

\subsubsection{Tecnologías del lado servidor} \label{sec:tecnologias-servidor}

En cuanto al lenguaje de programación del lado servidor es necesario elegir un lenguaje que permita la implementación de WebSockets para la comunicación en tiempo real, una API REST para servir los ficheros estáticos, que trabaje con ficheros para la creación de ficheros con el código del usuario, que permita la concurrencia para poder soportar varios usuarios al mismo tiempo, y que permita crear un proceso en el que ejecutar RR.
Dentro de las opciones destacan Python, Go, Rust y NodeJS, por lo que vamos a analizar cada una de ellas.

\begin{itemize}
    \item \textbf{Python}: Un lenguaje de programación interpretado, muy versátil, aunque con un rendimiento moderado. Gracias a frameworks como Flask para implementar APIs REST, aiohttp o FastAPI para WebSockets, y al módulo threading, para la concurrencia, es una opción viable.
    \item \textbf{Go}: Un lenguaje de programación compilado, con un buen rendimiento y orientado en la concurrencia y el procesamiento en la red. Su soporte nativo para WebSockets mediante goroutines, y frameworks como Gin o Echo para APIs REST lo hacen ideal para este tipo de comunicación.
    \item \textbf{Rust}: Un lenguaje de programación compilado, con un gran rendimiento, aunque con una curva de aprendizaje pronunciada. Tiene bibliotecas como Actix-web para APIs REST y WebSockets, pero no es la más recomendable por su complejidad. 
    \item \textbf{NodeJS}: Un lenguaje de programación interpretado con excelente soporte tanto para APIs REST (Express.js) como para WebSockets (Socket.io), aunque su concurrencia se basa en un solo hilo utilizando un bucle de eventos y un modelo asíncrono; lo que no es un paralelismo real. Su modelo no es ideal para operaciones intensivas en CPU.
\end{itemize}

Tanto Go como Python son lenguajes adecuados para el proyecto. Aunque Go ofrece un rendimiento superior, la disponibilidad de la biblioteca Python \textit{pygdbmi}, que facilita la gestión de una sesión RR/GDB y la obtención de la salida MI en formato JSON, convierte a Python en la opción más conveniente.

\section{Arquitectura del sistema}\label{sec:arquitectura-sistema}

Tal y como se ha comentado en \sectionref{estudio-solucion-final}, el sistema consta de tres partes: el cliente, el servidor y el contenedor docker, y cada uno de ellos consta de varios componentes. 

\begin{itemize}
    \item \textbf{Cliente}: Permite facilitar la interacción del usuario con el depurador, además de visualizar las salidas y cambios ocurridos durante la ejecución. En este componente se podrá escribir código, y comunicará las acciones al servidor para ejecutar las correspondientes funcionalidades. 
    Dentro de la aplicación web, existen dos componentes principales:

    \begin{itemize}
        \item \textbf{Intefaz Gráfica}: Su responsabilidad es actulizar la información que se muestra por pantalla-
        \item \textbf{Comunicación con el Servidor (Web Socket)}: Se encarga enviar y recibir mensajes del servidor.
        \item \textbf{Editor de Código} Su responsabilidad es permitir al usuario escribir el código que se va a depurar.
    \end{itemize}

    \item \textbf{Servidor}: Se encargará de gestionar las peticiones de los clientes y ejecutar las funcionalidades solicitadas en los contenedores
    Este componente consta de tres componentes principales:
    \begin{itemize}
        \item \textbf{Comunicación con el Cliente (Web Socket)}: Se encarga de aceptar las conexiones de los clientes y gestionar la comunicación entre el cliente y el servidor a través de Web Sockets.
        \item \textbf{Gestión de la Sesión de Depuración}: Se encarga de gestionar un contenedor docker para la sesión. Comunicará al contenedor las acciones que se realizan desde el cliente, y recibirá las respuestas del contenedor. 
    \end{itemize}

    \item \textbf{Contenedor Docker}: Se encarga de ejecutar el código del usuario y gestionar la sesión de depuración. Este componente consta de dos componentes principales:
    \begin{itemize}
        \item \textbf{Web Socket Docker}: El contenedor utilizará Web Socket para la comunicación con el servidor.
        \item \textbf{Funcionalidades de Depuración}: Este componente contendrá la implementación de las funcionalidades de depuración, las cuales serán llamadas a través de la API.
    \end{itemize}
\end{itemize}

En la figura \ref{fig:componentes_TFG} se muestra el diagrama de componentes UML \cite{Cook2017} donde se pueden observar los distintos componentes y sus diferentes interfaces.

\drawiosvgfigure[0.7]{componentes_TFG}{Diagrama de componentes del sistema}

Para la especificación de los distintos componentes se ha usado la siguiente plantilla: 

\printcomptemplate
% ------- Lado Cliente -------
\begin{component}{Interfaz Gráfica}
{Mostrar la información actualizada al usuario por pantalla}
{COM-Editor de Código, COM-Web Socket Cliente} % dependencias
{Estado actual del sistema} % in-data
{NA} % out-data
{FN-GUI, FN-aviso-error-concurrencia, FN-visualizacion-hilos, FN-visualizacion-evolucion} % relations
La Interfaz Gráfica debe de gestionar la interacción del usuario con la aplicación y mostrar la información de manera estructurada y clara. %description 
\end{component}

\begin{component}{Editor de Código}
    {Permitir al usuario escribir el código que se va a depurar}
    {\NA} % dependencias
    {\NA} % in-data
    {Código escrito, estado del editor de código} % out-data
    {FN-GUI, FN-GUI, FN-editor} % relations
    Este componente permitirá al usuario escribir código, colorear la sintaxis y gestionar de forma visual los breakpoints. %description
\end{component}

\begin{component}{Web Socket Cliente}
{Punto de comunicación por Web Socket desde el cliente al servidor}
{COM-Editor de Código, COM-Web Socket y REST API Servidor} % dependencias
{Mensajes del servidor} % in-data
{Cambios del sistema ,Mensajes del cliente} % out-data
{} % relations
La comunicación con el servidor se encargará de gestionar la comunicación entre el cliente y el servidor a través de Web Sockets. %description
\end{component}

% ------- Lado Servidor -------

\begin{component}{Web Socket y REST API Servidor}
{Punto de comunicación por Web Socket del servidor}
{COM-Web Socket Cliente, COM-Web Socket Docker, COM-Gestion de la Sesión de Depuración} % dependencias
{Mensajes del cliente, Mensajes del contenedor} % in-data
{Mensajes del cliente, Mensajes del contenedor, Acción sobre el contenedor} % out-data
{} % relations
Este componente aceptará comunicaciones con clientes y comunicará cliente con contenedor. %description
\end{component}

\begin{component}{Gestión de la Sesión de Depuración}
{Gestionar un contenedor docker para la sesión}
{} % dependencias
{Acción sobre el contenedor} % in-data
{\NA} % out-data
{} % relations
Se encarga de gestionar un contenedor docker para la sesión. %description
\end{component}

% ------ Lado Contenedor -------

\begin{component}{Web Socket Docker}
{Gestionar la comunicación entre el contenedor y el servidor a través de Web Sockets}
{COM-Web Socket y REST API Servidor} % dependencias
{Mensajes del servidor} % in-data
{Mensajes del contenedor} % out-data
{} % relations
La comunicación con el contenedor se encargará de gestionar la comunicación entre el contenedor y el servidor a través de Web Sockets. %description 
\end{component}

\begin{component}{Funcionalidades de Depuración}
{Gestionar la ejecución de las funcionalidades de depuración}
{} % dependencias
{Funcionalidad} % in-data
{Estado tras la ejecución de la funcionalidad} % out-data
{FN-fichero-codigo, FN-compilacion, FN-ejecutar, FN-depurar, FN-aviso-error-concurrencia, FN-step-over, FN-step-into, FN-step-out, FN-continuar-ejecucion, FN-rebobinar} % relations
Este componente ejecutará las funcionalidades del depurador y devolverá el resultado de aplicar esas funcionalidades %description
\end{component}

\FloatBarrier

\subsubsection{Trazabilidad} {\label{subsubsec:trazabilidad-comp}}

\traceabilityCompFN

